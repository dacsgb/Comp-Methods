<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>scipy.sparse.linalg.lobpcg &mdash; SciPy v1.3.0 Reference Guide</title>
    
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/scipy-mathjax/MathJax.js?config=scipy-mathjax"></script>
    <script type="text/javascript" src="../_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="../genindex.html" >
    <link rel="search" title="Search" href="../search.html" >
    <link rel="top" title="SciPy v1.3.0 Reference Guide" href="../index.html" >
    <link rel="up" title="Sparse linear algebra (scipy.sparse.linalg)" href="../sparse.linalg.html" >
    <link rel="next" title="scipy.sparse.linalg.svds" href="scipy.sparse.linalg.svds.html" >
    <link rel="prev" title="scipy.sparse.linalg.eigsh" href="scipy.sparse.linalg.eigsh.html" > 
  </head>
  <body>

  <div class="container">
    <div class="header">
    </div>
  </div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
	
        <li class="active"><a href="../index.html">SciPy v1.3.0 Reference Guide</a></li>
	
          <li class="active"><a href="../sparse.linalg.html" accesskey="U">Sparse linear algebra (<code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.sparse.linalg</span></code>)</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
      <li class="active">
        <a href="scipy.sparse.linalg.svds.html" title="scipy.sparse.linalg.svds"
           accesskey="N">next</a>
      </li>
      <li class="active">
        <a href="scipy.sparse.linalg.eigsh.html" title="scipy.sparse.linalg.eigsh"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/scipyshiny_small.png" alt="Logo">
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="scipy.sparse.linalg.eigsh.html"
                        title="previous chapter">scipy.sparse.linalg.eigsh</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="scipy.sparse.linalg.svds.html"
                        title="next chapter">scipy.sparse.linalg.svds</a></p>
<div id="searchbox" style="display: none" role="search">
  <h4>Quick search</h4>
    <div>
    <form class="search" action="../search.html" method="get">
      <input type="text" style="width: inherit;" name="q" />
      <input type="submit" value="search" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="scipy-sparse-linalg-lobpcg">
<h1>scipy.sparse.linalg.lobpcg<a class="headerlink" href="#scipy-sparse-linalg-lobpcg" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="scipy.sparse.linalg.lobpcg">
<code class="descclassname">scipy.sparse.linalg.</code><code class="descname">lobpcg</code><span class="sig-paren">(</span><em>A</em>, <em>X</em>, <em>B=None</em>, <em>M=None</em>, <em>Y=None</em>, <em>tol=None</em>, <em>maxiter=20</em>, <em>largest=True</em>, <em>verbosityLevel=0</em>, <em>retLambdaHistory=False</em>, <em>retResidualNormsHistory=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scipy/scipy/blob/v1.3.0/scipy/sparse/linalg/eigen/lobpcg/lobpcg.py#L119-L651"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scipy.sparse.linalg.lobpcg" title="Permalink to this definition">¶</a></dt>
<dd><p>Locally Optimal Block Preconditioned Conjugate Gradient Method (LOBPCG)</p>
<p>LOBPCG is a preconditioned eigensolver for large symmetric positive
definite (SPD) generalized eigenproblems.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">{sparse matrix, dense matrix, LinearOperator}</span></dt><dd><p>The symmetric linear operator of the problem, usually a
sparse matrix.  Often called the “stiffness matrix”.</p>
</dd>
<dt><strong>X</strong><span class="classifier">array_like</span></dt><dd><p>Initial approximation to the k eigenvectors. If A has
shape=(n,n) then X should have shape shape=(n,k).</p>
</dd>
<dt><strong>B</strong><span class="classifier">{dense matrix, sparse matrix, LinearOperator}, optional</span></dt><dd><p>the right hand side operator in a generalized eigenproblem.
by default, B = Identity
often called the “mass matrix”</p>
</dd>
<dt><strong>M</strong><span class="classifier">{dense matrix, sparse matrix, LinearOperator}, optional</span></dt><dd><p>preconditioner to A; by default M = Identity
M should approximate the inverse of A</p>
</dd>
<dt><strong>Y</strong><span class="classifier">array_like, optional</span></dt><dd><p>n-by-sizeY matrix of constraints, sizeY &lt; n
The iterations will be performed in the B-orthogonal complement
of the column-space of Y. Y must be full rank.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">scalar, optional</span></dt><dd><p>Solver tolerance (stopping criterion)
by default: tol=n*sqrt(eps)</p>
</dd>
<dt><strong>maxiter</strong><span class="classifier">integer, optional</span></dt><dd><p>maximum number of iterations
by default: maxiter=min(n,20)</p>
</dd>
<dt><strong>largest</strong><span class="classifier">bool, optional</span></dt><dd><p>when True, solve for the largest eigenvalues, otherwise the smallest</p>
</dd>
<dt><strong>verbosityLevel</strong><span class="classifier">integer, optional</span></dt><dd><p>controls solver output.  default: verbosityLevel = 0.</p>
</dd>
<dt><strong>retLambdaHistory</strong><span class="classifier">boolean, optional</span></dt><dd><p>whether to return eigenvalue history</p>
</dd>
<dt><strong>retResidualNormsHistory</strong><span class="classifier">boolean, optional</span></dt><dd><p>whether to return history of residual norms</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">array</span></dt><dd><p>Array of k eigenvalues</p>
</dd>
<dt><strong>v</strong><span class="classifier">array</span></dt><dd><p>An array of k eigenvectors.  V has the same shape as X.</p>
</dd>
<dt><strong>lambdas</strong><span class="classifier">list of arrays, optional</span></dt><dd><p>The eigenvalue history, if <em class="xref py py-obj">retLambdaHistory</em> is True.</p>
</dd>
<dt><strong>rnorms</strong><span class="classifier">list of arrays, optional</span></dt><dd><p>The history of residual norms, if <em class="xref py py-obj">retResidualNormsHistory</em> is True.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If both retLambdaHistory and retResidualNormsHistory are True,
the return tuple has the following format
(lambda, V, lambda history, residual norms history).</p>
<p>In the following <code class="docutils literal notranslate"><span class="pre">n</span></code> denotes the matrix size and <code class="docutils literal notranslate"><span class="pre">m</span></code> the number
of required eigenvalues (smallest or largest).</p>
<p>The LOBPCG code internally solves eigenproblems of the size 3``m`` on every
iteration by calling the “standard” dense eigensolver, so if <code class="docutils literal notranslate"><span class="pre">m</span></code> is not
small enough compared to <code class="docutils literal notranslate"><span class="pre">n</span></code>, it does not make sense to call the LOBPCG
code, but rather one should use the “standard” eigensolver,
e.g. numpy or scipy function in this case.
If one calls the LOBPCG algorithm for 5``m``&gt;``n``,
it will most likely break internally, so the code tries to call
the standard function instead.</p>
<p>It is not that n should be large for the LOBPCG to work, but rather the
ratio <code class="docutils literal notranslate"><span class="pre">n</span></code>/<code class="docutils literal notranslate"><span class="pre">m</span></code> should be large. It you call LOBPCG with <code class="docutils literal notranslate"><span class="pre">m``=1</span>
<span class="pre">and</span> <span class="pre">``n``=10,</span> <span class="pre">it</span> <span class="pre">works</span> <span class="pre">though</span> <span class="pre">``n</span></code> is small. The method is intended
for extremely large <code class="docutils literal notranslate"><span class="pre">n</span></code>/<code class="docutils literal notranslate"><span class="pre">m</span></code>, see e.g., reference [28] in
<a class="reference external" href="https://arxiv.org/abs/0705.2626">https://arxiv.org/abs/0705.2626</a></p>
<p>The convergence speed depends basically on two factors:</p>
<ol class="arabic simple">
<li><p>How well relatively separated the seeking eigenvalues are from the rest
of the eigenvalues. One can try to vary <code class="docutils literal notranslate"><span class="pre">m</span></code> to make this better.</p></li>
<li><p>How well conditioned the problem is. This can be changed by using proper
preconditioning. For example, a rod vibration test problem (under tests
directory) is ill-conditioned for large <code class="docutils literal notranslate"><span class="pre">n</span></code>, so convergence will be
slow, unless efficient preconditioning is used. For this specific
problem, a good simple preconditioner function would be a linear solve
for A, which is easy to code since A is tridiagonal.</p></li>
</ol>
<p><em>Acknowledgements</em></p>
<p>lobpcg.py code was written by Robert Cimrman.
Many thanks belong to Andrew Knyazev, the author of the algorithm,
for lots of advice and support.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rbbbc6164e7a5-1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>A. V. Knyazev (2001),
Toward the Optimal Preconditioned Eigensolver: Locally Optimal
Block Preconditioned Conjugate Gradient Method.
SIAM Journal on Scientific Computing 23, no. 2,
pp. 517-541. <a class="reference external" href="http://dx.doi.org/10.1137/S1064827500366124">http://dx.doi.org/10.1137/S1064827500366124</a></p>
</dd>
<dt class="label" id="rbbbc6164e7a5-2"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>A. V. Knyazev, I. Lashuk, M. E. Argentati, and E. Ovchinnikov
(2007), Block Locally Optimal Preconditioned Eigenvalue Xolvers
(BLOPEX) in hypre and PETSc. <a class="reference external" href="https://arxiv.org/abs/0705.2626">https://arxiv.org/abs/0705.2626</a></p>
</dd>
<dt class="label" id="rbbbc6164e7a5-3"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>A. V. Knyazev’s C and MATLAB implementations:
<a class="reference external" href="https://bitbucket.org/joseroman/blopex">https://bitbucket.org/joseroman/blopex</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Solve A x = lambda B x with constraints and preconditioning.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="k">import</span> <span class="n">spdiags</span><span class="p">,</span> <span class="n">issparse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="k">import</span> <span class="n">lobpcg</span><span class="p">,</span> <span class="n">LinearOperator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spdiags</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="go">array([[  1.,   0.,   0., ...,   0.,   0.,   0.],</span>
<span class="go">       [  0.,   2.,   0., ...,   0.,   0.,   0.],</span>
<span class="go">       [  0.,   0.,   3., ...,   0.,   0.,   0.],</span>
<span class="go">       ...,</span>
<span class="go">       [  0.,   0.,   0., ...,  98.,   0.,   0.],</span>
<span class="go">       [  0.,   0.,   0., ...,   0.,  99.,   0.],</span>
<span class="go">       [  0.,   0.,   0., ...,   0.,   0., 100.]])</span>
</pre></div>
</div>
<p>Constraints.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Initial guess for eigenvectors, should have linearly independent
columns. Column dimension = number of requested eigenvalues.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Preconditioner – inverse of A (as an abstract linear operator).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">invA</span> <span class="o">=</span> <span class="n">spdiags</span><span class="p">([</span><span class="mf">1.</span><span class="o">/</span><span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">precond</span><span class="p">(</span> <span class="n">x</span> <span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">invA</span>  <span class="o">*</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">LinearOperator</span><span class="p">(</span><span class="n">matvec</span><span class="o">=</span><span class="n">precond</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">invA</span></code> could of course have been used directly as a preconditioner.
Let us then solve the problem:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eigs</span><span class="p">,</span> <span class="n">vecs</span> <span class="o">=</span> <span class="n">lobpcg</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span> <span class="n">largest</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eigs</span>
<span class="go">array([4., 5., 6.])</span>
</pre></div>
</div>
<p>Note that the vectors passed in Y are the eigenvectors of the 3 smallest
eigenvalues. The results returned are orthogonal to those.</p>
</dd></dl>

</div>


          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2008-2019, The SciPy community.
      </li>
      <li>
      Last updated on May 17, 2019.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 2.0.1.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>